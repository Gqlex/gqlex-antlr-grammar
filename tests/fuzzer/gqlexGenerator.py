# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class gqlexGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def NEGATIVE_SIGN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEGATIVE_SIGN', parent=parent)) as current:
            UnlexerRule(src='-', parent=current)
            return current
    NEGATIVE_SIGN.min_depth = 0

    def NONZERO_DIGIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NONZERO_DIGIT', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            return current
    NONZERO_DIGIT.min_depth = 0

    def DIGIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIGIT', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
            return current
    DIGIT.min_depth = 0

    def LETTER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LETTER', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[3]), parent=current)
            return current
    LETTER.min_depth = 0

    def NAME_START(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NAME_START', parent=parent)) as current:
            with AlternationContext(self, [1, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [None, '_'][choice0]
                rule = [self.LETTER, None][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    NAME_START.min_depth = 0

    def NAME_CONTINUE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NAME_CONTINUE', parent=parent)) as current:
            with AlternationContext(self, [1, 0, 1], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [None, '_', None][choice0]
                rule = [self.LETTER, None, self.DIGIT][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    NAME_CONTINUE.min_depth = 0

    def SLASH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SLASH', parent=parent)) as current:
            UnlexerRule(src='/', parent=current)
            return current
    SLASH.min_depth = 0

    def DOUBLE_SLASH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DOUBLE_SLASH', parent=parent)) as current:
            UnlexerRule(src='//', parent=current)
            return current
    DOUBLE_SLASH.min_depth = 0

    def DOTS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DOTS', parent=parent)) as current:
            UnlexerRule(src='...', parent=current)
            return current
    DOTS.min_depth = 0

    def RANGE_OPEN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RANGE_OPEN', parent=parent)) as current:
            UnlexerRule(src='{', parent=current)
            return current
    RANGE_OPEN.min_depth = 0

    def RANGE_CLOSE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RANGE_CLOSE', parent=parent)) as current:
            UnlexerRule(src='}', parent=current)
            return current
    RANGE_CLOSE.min_depth = 0

    def COLON(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COLON', parent=parent)) as current:
            UnlexerRule(src=':', parent=current)
            return current
    COLON.min_depth = 0

    def EQUALS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EQUALS', parent=parent)) as current:
            UnlexerRule(src='=', parent=current)
            return current
    EQUALS.min_depth = 0

    def LBRACK(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LBRACK', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            return current
    LBRACK.min_depth = 0

    def RBRACK(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RBRACK', parent=parent)) as current:
            UnlexerRule(src=']', parent=current)
            return current
    RBRACK.min_depth = 0

    def LPAREN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LPAREN', parent=parent)) as current:
            UnlexerRule(src='(', parent=current)
            return current
    LPAREN.min_depth = 0

    def RPAREN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RPAREN', parent=parent)) as current:
            UnlexerRule(src=')', parent=current)
            return current
    RPAREN.min_depth = 0

    def COND_EQ(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_EQ', parent=parent)) as current:
            UnlexerRule(src='==', parent=current)
            return current
    COND_EQ.min_depth = 0

    def COND_NE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_NE', parent=parent)) as current:
            UnlexerRule(src='!=', parent=current)
            return current
    COND_NE.min_depth = 0

    def COND_GT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_GT', parent=parent)) as current:
            UnlexerRule(src='>', parent=current)
            return current
    COND_GT.min_depth = 0

    def COND_GE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_GE', parent=parent)) as current:
            UnlexerRule(src='>=', parent=current)
            return current
    COND_GE.min_depth = 0

    def COND_LT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_LT', parent=parent)) as current:
            UnlexerRule(src='<', parent=current)
            return current
    COND_LT.min_depth = 0

    def COND_LE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_LE', parent=parent)) as current:
            UnlexerRule(src='<=', parent=current)
            return current
    COND_LE.min_depth = 0

    def COND_AND(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_AND', parent=parent)) as current:
            UnlexerRule(src='&&', parent=current)
            return current
    COND_AND.min_depth = 0

    def COND_OR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COND_OR', parent=parent)) as current:
            UnlexerRule(src='||', parent=current)
            return current
    COND_OR.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[4]), parent=current)
            return current
    WS.min_depth = 0

    def POSITIVE_INT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='POSITIVE_INT', parent=parent)) as current:
            self.NONZERO_DIGIT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.DIGIT(parent=current)
            return current
    POSITIVE_INT.min_depth = 1

    def NEGATIVE_INT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEGATIVE_INT', parent=parent)) as current:
            self.NEGATIVE_SIGN(parent=current)
            self.POSITIVE_INT(parent=current)
            return current
    NEGATIVE_INT.min_depth = 2

    def NAME(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NAME', parent=parent)) as current:
            self.NAME_START(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.NAME_CONTINUE(parent=current)
            return current
    NAME.min_depth = 1

    def document(self, parent=None):
        with RuleContext(self, UnparserRule(name='document', parent=parent)) as current:
            self.pathExpression(parent=current)
            self.EOF(parent=current)
            return current
    document.min_depth = 3

    def pathExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='pathExpression', parent=parent)) as current:
            with AlternationContext(self, [2, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.rootPathExpression, self.rangePathExpression][choice0](parent=current)
            return current
    pathExpression.min_depth = 2

    def rootPathExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='rootPathExpression', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.DOUBLE_SLASH, self.SLASH][choice0](parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.pathElement(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.SLASH(parent=current)
                            self.pathElement(parent=current)
            return current
    rootPathExpression.min_depth = 1

    def rangePathExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='rangePathExpression', parent=parent)) as current:
            self.RANGE_OPEN(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.rangeStartIntValue(parent=current)
            self.COLON(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.rangeEndIntValue(parent=current)
            self.RANGE_CLOSE(parent=current)
            self.rootPathExpression(parent=current)
            return current
    rangePathExpression.min_depth = 2

    def elementSelectionExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='elementSelectionExpression', parent=parent)) as current:
            self.nameValue(parent=current)
            self.EQUALS(parent=current)
            self.nameValue(parent=current)
            return current
    elementSelectionExpression.min_depth = 3

    def pathElement(self, parent=None):
        with RuleContext(self, UnparserRule(name='pathElement', parent=parent)) as current:
            with AlternationContext(self, [3, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.nameValue(parent=current)
                    if self._max_depth >= 4:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.LBRACK(parent=current)
                            self.elementSelectionExpression(parent=current)
                            self.RBRACK(parent=current)
                    if self._max_depth >= 4:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.LPAREN(parent=current)
                            self.conditionExpression(parent=current)
                            self.RPAREN(parent=current)
                elif choice0 == 1:
                    self.DOTS(parent=current)
            return current
    pathElement.min_depth = 1

    def conditionOperator(self, parent=None):
        with RuleContext(self, UnparserRule(name='conditionOperator', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.COND_EQ, self.COND_NE, self.COND_GT, self.COND_GE, self.COND_LT, self.COND_LE][choice0](parent=current)
            return current
    conditionOperator.min_depth = 1

    def conditionLogicalOperator(self, parent=None):
        with RuleContext(self, UnparserRule(name='conditionLogicalOperator', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.COND_AND, self.COND_OR][choice0](parent=current)
            return current
    conditionLogicalOperator.min_depth = 1

    def conditionExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='conditionExpression', parent=parent)) as current:
            with AlternationContext(self, [3, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.nameValue(parent=current)
                    self.conditionOperator(parent=current)
                    with AlternationContext(self, [3, 1], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.nameValue, self.intValue][choice1](parent=current)
                elif choice0 == 1:
                    self.conditionExpression(parent=current)
                    self.conditionLogicalOperator(parent=current)
                    self.conditionExpression(parent=current)
            return current
    conditionExpression.min_depth = 3

    def nameValue(self, parent=None):
        with RuleContext(self, UnparserRule(name='nameValue', parent=parent)) as current:
            self.NAME(parent=current)
            return current
    nameValue.min_depth = 2

    def intValue(self, parent=None):
        with RuleContext(self, UnparserRule(name='intValue', parent=parent)) as current:
            with AlternationContext(self, [2, 3, 0], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [None, None, '0'][choice0]
                rule = [self.POSITIVE_INT, self.NEGATIVE_INT, None][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    intValue.min_depth = 0

    def rangeEndIntValue(self, parent=None):
        with RuleContext(self, UnparserRule(name='rangeEndIntValue', parent=parent)) as current:
            self.POSITIVE_INT(parent=current)
            return current
    rangeEndIntValue.min_depth = 2

    def rangeStartIntValue(self, parent=None):
        with RuleContext(self, UnparserRule(name='rangeStartIntValue', parent=parent)) as current:
            with AlternationContext(self, [2, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [None, '0'][choice0]
                rule = [self.POSITIVE_INT, None][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    rangeStartIntValue.min_depth = 0

    _default_rule = NEGATIVE_SIGN

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(49, 58)])),
        2: list(itertools.chain.from_iterable([range(48, 58)])),
        3: list(itertools.chain.from_iterable([range(65, 91), range(97, 123)])),
        4: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
    }
